# A robust function to check, validate, and install a given dependency.
install_dependency() {
    local cmd_name="$1"      # The command to check for (e.g., "gum")
    local brew_pkg="$2"      # The package name for Homebrew (e.g., "gum")
    local apt_pkg="$3"       # The package name for apt (Debian/Ubuntu)
    local dnf_pkg="$4"       # The package name for dnf (Fedora/RHEL) - can differ from apt
    local binary_url="$5"    # Optional URL to a binary/tarball for fallback

    # If dnf_pkg not specified, default to apt_pkg
    if [ -z "$dnf_pkg" ]; then
        dnf_pkg="$apt_pkg"
    fi

    # 1. Validate the command. If it runs, we're done.
    if command -v "$cmd_name" &>/dev/null; then
        # Special case: some commands don't support --version
        if [[ "$cmd_name" == "mariadb" ]] || "$cmd_name" --version &>/dev/null 2>&1; then
            echo "‚úÖ $cmd_name is already installed and valid."
            return 0
        fi
    fi

    # If gum isn't installed yet, we can't use it for styling this first message.
    if ! command -v gum &>/dev/null; then
        echo "--- Installing Dependency: $cmd_name ---"
    else
        gum style --border normal --margin "1" --padding "1 2" --border-foreground 212 "Installing Dependency: $cmd_name"
    fi

    local installed_successfully=false
    local pkg_name=""

    # 2. Attempt installation with the native package manager.
    if [ "$OS" == "macos" ]; then
        if brew install "$brew_pkg"; then
            installed_successfully=true
        fi
    else # For Linux (apt/dnf)
        # Determine the correct package name for this distro
        if [ "$PKG_MANAGER" == "apt" ]; then
            pkg_name="$apt_pkg"
        else
            pkg_name="$dnf_pkg"
        fi
        
        # Only try native package manager if a name is provided
        if [ -n "$pkg_name" ]; then
            echo "   - Updating package cache..."
            if [ "$PKG_MANAGER" == "apt" ]; then
                $SUDO_CMD apt-get update -qq >/dev/null 2>&1
            else
                $SUDO_CMD dnf makecache -q >/dev/null 2>&1 || true
            fi
            
            echo "   - Installing $pkg_name via $PKG_MANAGER..."
            if [ "$PKG_MANAGER" == "apt" ]; then
                if $SUDO_CMD apt-get install -y "$pkg_name" >/dev/null 2>&1; then
                    installed_successfully=true
                fi
            else
                if $SUDO_CMD dnf install -y "$pkg_name" >/dev/null 2>&1; then
                    installed_successfully=true
                fi
            fi
        fi
        
        # 3. If native package fails or isn't specified, and a binary URL is provided, try that.
        if [ "$installed_successfully" = false ] && [ -n "$binary_url" ]; then
            if ! command -v gum &>/dev/null; then
                 echo "   - Native package not available. Falling back to binary download."
            else
                gum style --foreground "yellow" "   - Native package not available. Falling back to binary download."
            fi
            
            local temp_dir
            temp_dir=$(mktemp -d)
            
            # Check if URL is a tarball or direct binary
            if [[ "$binary_url" == *.tar.gz ]] || [[ "$binary_url" == *.tgz ]]; then
                echo "   - Downloading and extracting tarball..."
                if curl -sL "$binary_url" | tar -xz -C "$temp_dir" 2>/dev/null; then
                    # Find the binary in extracted contents
                    local binary_file
                    binary_file=$(find "$temp_dir" -name "$cmd_name" -type f -executable 2>/dev/null | head -1)
                    if [ -z "$binary_file" ]; then
                        # Try without executable flag (might need chmod)
                        binary_file=$(find "$temp_dir" -name "$cmd_name" -type f 2>/dev/null | head -1)
                    fi
                    if [ -n "$binary_file" ]; then
                        chmod +x "$binary_file"
                        if $SUDO_CMD mv "$binary_file" "$BIN_DIR/$cmd_name"; then
                            installed_successfully=true
                        fi
                    fi
                fi
            else
                # Direct binary download
                echo "   - Downloading binary..."
                if curl -sL "$binary_url" -o "$temp_dir/$cmd_name"; then
                    chmod +x "$temp_dir/$cmd_name"
                    if $SUDO_CMD mv "$temp_dir/$cmd_name" "$BIN_DIR/$cmd_name"; then
                        installed_successfully=true
                    fi
                fi
            fi
            rm -rf "$temp_dir"
        fi
    fi

    # 4. Final verification and cache clearing.
    if [ "$installed_successfully" = true ]; then
        hash -r # Clear the shell's command cache for this script session.
        if command -v "$cmd_name" &>/dev/null; then
            echo "‚úÖ $cmd_name installed successfully."
            return 0
        else
            echo "‚ö†Ô∏è  $cmd_name installed but not found in PATH. You may need to restart your shell."
            return 0
        fi
    else
        if command -v gum &>/dev/null; then
            gum style --foreground red "‚ùå Failed to install $cmd_name."
        else
            echo "‚ùå Failed to install $cmd_name."
        fi
        exit 1
    fi
}

# Install PHP with required extensions for WordPress development
install_php_with_extensions() {
    echo "üì¶ Installing PHP with required extensions..."
    
    if [ "$OS" == "macos" ]; then
        # macOS: PHP from Homebrew includes most extensions
        if ! command -v php &>/dev/null; then
            brew install php
        fi
        echo "‚úÖ PHP installed via Homebrew."
        return 0
    fi
    
    # Linux: Need to install PHP and extensions separately
    local php_packages=""
    
    if [ "$PKG_MANAGER" == "apt" ]; then
        # Note: php-mysql is a metapackage, php-mysqli is the actual extension
        php_packages="php php-cli php-fpm php-mysql php-mysqli php-xml php-mbstring php-curl php-gd php-zip php-intl php-bcmath php-soap"
        echo "   - Updating package cache..."
        $SUDO_CMD apt-get update -qq
        echo "   - Installing PHP and extensions..."
        # Show output so we can see what's happening
        if $SUDO_CMD apt-get install -y $php_packages; then
            echo "‚úÖ PHP and extensions installed successfully."
        else
            echo "‚ö†Ô∏è  Some PHP packages may have failed. Trying individual packages..."
            # Try installing core packages individually
            for pkg in php php-cli php-mysql php-mysqli php-xml php-mbstring php-curl; do
                $SUDO_CMD apt-get install -y "$pkg" 2>/dev/null || true
            done
        fi
    else
        # Fedora/RHEL - package names differ slightly
        php_packages="php php-cli php-fpm php-mysqlnd php-xml php-mbstring php-curl php-gd php-zip php-intl php-bcmath php-soap"
        echo "   - Installing PHP and extensions..."
        if $SUDO_CMD dnf install -y $php_packages; then
            echo "‚úÖ PHP and extensions installed successfully."
        else
            echo "‚ö†Ô∏è  Some PHP packages may have failed. Trying individual packages..."
            for pkg in php php-cli php-mysqlnd php-xml php-mbstring php-curl; do
                $SUDO_CMD dnf install -y "$pkg" 2>/dev/null || true
            done
        fi
    fi
    
    # Verify mysqli extension is available
    echo "   - Verifying PHP mysqli extension..."
    if php -m 2>/dev/null | grep -qi mysqli; then
        echo "‚úÖ PHP mysqli extension is available."
    else
        echo ""
        gum style --foreground red "‚ö†Ô∏è  WARNING: PHP mysqli extension not found!"
        echo "   WordPress and Adminer require mysqli to connect to MySQL/MariaDB."
        echo ""
        echo "   Try installing it manually:"
        if [ "$PKG_MANAGER" == "apt" ]; then
            echo "     sudo apt-get install php-mysqli"
        else
            echo "     sudo dnf install php-mysqlnd"
        fi
        echo ""
    fi
    
    return 0
}

cove_install() {
    echo "üöÄ Starting Cove installation..."

    # --- WSL/Systemd Check ---
    if [ "$OS" == "linux" ]; then
        if [ "$IS_WSL" = true ]; then
            echo "üêß WSL environment detected."
            # Check if systemd is running
            if ! pidof systemd >/dev/null 2>&1; then
                echo ""
                echo "‚ö†Ô∏è  WARNING: systemd is not running in WSL."
                echo "   Cove requires systemd for service management."
                echo ""
                echo "   To enable systemd in WSL2, add to /etc/wsl.conf:"
                echo "   [boot]"
                echo "   systemd=true"
                echo ""
                echo "   Then restart WSL with: wsl --shutdown"
                echo ""
                read -p "Do you want to continue anyway? (y/N) " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "üö´ Installation cancelled."
                    exit 0
                fi
            fi
        fi
    fi

    # Check for services using standard web ports
    # Use ss as fallback if lsof is not available (common on minimal Linux installs)
    local port_check_cmd=""
    if command -v lsof &>/dev/null; then
        port_check_cmd="lsof"
    elif command -v ss &>/dev/null; then
        port_check_cmd="ss"
    fi
    
    if [ -n "$port_check_cmd" ]; then
        local ports_in_use=false
        local listening_app=""
        
        if [ "$port_check_cmd" == "lsof" ]; then
            if lsof -i :80 -i :443 2>/dev/null | grep -q 'LISTEN'; then
                ports_in_use=true
                listening_app=$(lsof -i :80 -i :443 2>/dev/null | grep 'LISTEN' | awk '{print $1}' | sort -u | tr '\n' ' ' | sed 's/ $//')
            fi
        else
            # Use ss for port checking
            if ss -tlnp 2>/dev/null | grep -qE ':80\s|:443\s'; then
                ports_in_use=true
                listening_app=$(ss -tlnp 2>/dev/null | grep -E ':80\s|:443\s' | sed 's/.*users:(("\([^"]*\)".*/\1/' | sort -u | tr '\n' ' ')
            fi
        fi
        
        if [ "$ports_in_use" = true ]; then
            if [[ "$listening_app" != *"$CADDY_CMD"* && "$listening_app" != *"frankenph"* ]]; then
                echo "‚ö†Ô∏è  Warning: A conflicting web server ('${listening_app}') may be running!"
                echo "Cove needs ports 80/443 to function."
                read -p "Do you want to proceed with the installation anyway? (y/N) " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "üö´ Installation cancelled."
                    exit 0
                fi
            fi
        fi
    fi
    
    # --- Dependency Installation ---
    # Gum - Terminal UI library (needed first for nice prompts)
    # Note: gum releases use format: gum_VERSION_Linux_x86_64.tar.gz
    local gum_arch="x86_64"
    if [ "$(uname -m)" == "aarch64" ] || [ "$(uname -m)" == "arm64" ]; then
        gum_arch="arm64"
    fi
    local gum_url="https://github.com/charmbracelet/gum/releases/download/v0.14.1/gum_0.14.1_Linux_${gum_arch}.tar.gz"
    install_dependency "gum" "gum" "gum" "gum" "$gum_url"

    # --- Pre-install Checks ---
    if [ -d "$COVE_DIR" ]; then
        if ! gum confirm "‚ö†Ô∏è The Cove directory (~/Cove) already exists. Proceeding may overwrite some configurations. Continue?"; then
            echo "üö´ Installation cancelled."
            exit 0
        fi
    fi
    
    # FrankenPHP uses its own universal installer
    if ! command -v frankenphp &> /dev/null; then
        gum style --border normal --margin "1" --padding "1 2" --border-foreground 212 "Installing Dependency: frankenphp"
        echo "   - Using the official FrankenPHP installer..."
        if curl -sL https://frankenphp.dev/install.sh | $SUDO_CMD bash; then
             echo "‚úÖ FrankenPHP installed successfully."
        else
            gum style --foreground red "‚ùå The FrankenPHP download script failed."
            exit 1
        fi
    else
        echo "‚úÖ FrankenPHP is already installed."
    fi

    # MariaDB - Database server
    install_dependency "mariadb" "mariadb" "mariadb-server" "mariadb-server" ""
    
    # PHP with extensions (uses dedicated function for Linux)
    if [ "$OS" == "macos" ]; then
        install_dependency "php" "php" "" "" ""
    else
        install_php_with_extensions
    fi

    # Mailpit - Email testing tool (uses its own universal installer)
    if ! command -v mailpit &> /dev/null; then
        gum style --border normal --margin "1" --padding "1 2" --border-foreground 212 "Installing Dependency: mailpit"
        echo "   - Using the official Mailpit installer..."
        if curl -sL https://raw.githubusercontent.com/axllent/mailpit/develop/install.sh | $SUDO_CMD bash; then
            echo "‚úÖ Mailpit installed successfully."
        else
            gum style --foreground red "‚ùå The Mailpit download script failed."
            exit 1
        fi
    else
        echo "‚úÖ Mailpit is already installed."
    fi

    # WP-CLI - WordPress command line tool
    # Not in default Linux repos, so we use the phar download as fallback
    install_dependency "wp" "wp-cli" "" "" "https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar"

    # --- Directory and Service Setup (Copied from original file) ---
    echo "üìÅ Creating Cove directory structure..."
    mkdir -p "$SITES_DIR" "$LOGS_DIR" "$GUI_DIR" "$ADMINER_DIR" "$CUSTOM_CADDY_DIR"
    echo "üóÉÔ∏è Downloading Adminer 5.4.1..."
    curl -sL "https://github.com/vrana/adminer/releases/download/v5.4.1/adminer-5.4.1.php" -o "$ADMINER_DIR/adminer-core.php"
    echo "‚öôÔ∏è Creating Adminer autologin..."
    # Create a custom index.php to handle autologin
    # Note: Adminer 5.x uses the Adminer\Adminer namespace
    cat > "$ADMINER_DIR/index.php" << 'EOM'
<?php
// This is the custom entry point for Adminer with autologin.
function adminer_object() {
    // Adminer 5.x uses the Adminer namespace
    class AdminerCoveLogin extends Adminer\Adminer {
        function name() { return 'Cove DB Manager'; }
        function permanentLogin($i = false) { return "cove-local-development-key"; }
        function credentials() {
            $configFile = getenv('HOME') . '/Cove/config';
            if (file_exists($configFile)) {
                $config = parse_ini_file($configFile);
                $db_user = $config['DB_USER'] ?? null;
                $db_pass = $config['DB_PASSWORD'] ?? null;
                return ['localhost', $db_user, $db_pass];
            }
            return ['localhost', null, null];
        }
        function login($login, $password) { return true; }
    }
    return new AdminerCoveLogin();
}
// Include the original Adminer core file to run the application.
include "./adminer-core.php";
EOM

    echo "üé® Downloading Adminer Catppuccin theme..."
    curl -sL "https://raw.githubusercontent.com/anchorhost/cove/main/adminer-theme/adminer.css" -o "$ADMINER_DIR/adminer.css"

    echo "‚ú® Downloading Whoops error handler..."
    rm -rf "$APP_DIR/whoops" # Remove any old versions first
    mkdir -p "$APP_DIR/whoops"
    curl -sL "https://github.com/filp/whoops/archive/refs/tags/2.15.3.tar.gz" | tar -xz -C "$APP_DIR/whoops" --strip-components=1

    echo "‚öôÔ∏è Starting services..."
    if [ "$OS" == "macos" ]; then
        if ! brew services restart mariadb; then
            gum style --foreground red "‚ùå Failed to start MariaDB via Homebrew."
            exit 1
        fi
    else # Linux
        if ! $SUDO_CMD systemctl restart mariadb; then
            gum style --foreground red "‚ùå Failed to start MariaDB via systemctl."
            exit 1
        fi
    fi

    # --- Database Configuration ---
    if [ -f "$CONFIG_FILE" ] && gum confirm "Existing Cove database config found. Use it and skip database setup?"; then
        echo "‚úÖ Using existing database configuration."
    else
        gum style --border normal --margin "1" --padding "1 2" --border-foreground 212 "Configuring MariaDB"
        echo "   - Waiting for MariaDB service..."
        i=0
        while ! mysqladmin ping --silent; do
            sleep 1;
            i=$((i+1))
            if [ $i -ge 20 ]; then
                gum style --foreground red "‚ùå MariaDB did not become available in time."
                exit 1
            fi
        done
        echo "   - ‚úÖ MariaDB is ready."
        local db_user="cove_user"
        local db_pass
        db_pass=$(openssl rand -base64 16)
        local sql_command="DROP USER IF EXISTS '$db_user'@'localhost'; CREATE USER '$db_user'@'localhost' IDENTIFIED BY '$db_pass'; GRANT ALL PRIVILEGES ON *.* TO '$db_user'@'localhost' WITH GRANT OPTION; FLUSH PRIVILEGES;"
        local user_created_successfully=false

        echo "   - Attempting automatic setup..."
        if echo "$sql_command" | $SUDO_CMD mysql &> /dev/null; then
            echo "   - ‚úÖ Automatic database user creation successful."
            user_created_successfully=true
        else
            echo "   - ‚ö†Ô∏è Automatic setup failed. Falling back to manual credential entry..."
            local root_user
            root_user=$(gum input --value "root" --prompt "MariaDB Root Username: ")
            local root_pass
            root_pass=$(gum input --password --placeholder "Password for '$root_user'")

            if echo "$sql_command" | mysql -u "$root_user" -p"$root_pass"; then
                echo "   - ‚úÖ Manual database user creation successful."
                user_created_successfully=true
            fi
        fi

        if $user_created_successfully; then
            echo "   - üìù Saving new configuration..."
            echo "DB_USER='$db_user'" > "$CONFIG_FILE"
            echo "DB_PASSWORD='$db_pass'" >> "$CONFIG_FILE"
        else
            gum style --foreground red "‚ùå Database user creation failed. Please check credentials and MariaDB logs."
            exit 1
        fi
    fi
    
    # --- Finalize ---
    create_whoops_bootstrap
    create_gui_file
    regenerate_caddyfile

    echo "‚úÖ Initial configuration complete. Starting services..."
    cove_enable
    
    # Show post-install guidance
    echo ""
    gum style --border normal --margin "1" --padding "1 2" --border-foreground "yellow" \
        "üìã First-Time Setup Notes"
    echo ""
    echo "  Your browser will show a certificate warning when accessing Cove sites."
    echo "  This is normal for local development with self-signed certificates."
    echo ""
    echo "  Options to resolve:"
    echo "    1. Click 'Advanced' and 'Proceed' to accept the certificate"
    echo "    2. Or trust Caddy's root CA certificate system-wide (recommended)"
    echo ""
    if [ "$OS" == "macos" ]; then
        echo "  On macOS, Caddy typically auto-trusts its CA. If not, the CA cert is at:"
        echo "    ~/Library/Application Support/Caddy/pki/authorities/local/root.crt"
    else
        echo "  On Linux, the CA certificate is located at:"
        echo "    ~/.local/share/caddy/pki/authorities/local/root.crt"
        echo ""
        echo "  To trust it system-wide (Ubuntu/Debian):"
        echo "    sudo cp ~/.local/share/caddy/pki/authorities/local/root.crt /usr/local/share/ca-certificates/caddy.crt"
        echo "    sudo update-ca-certificates"
        echo ""
        echo "  For browser-only trust, import the certificate in your browser settings."
    fi
    
    if [ "$IS_WSL" = true ]; then
        echo ""
        gum style --foreground yellow "  WSL: Run 'cove wsl-hosts' for Windows hosts file setup instructions."
    fi
}